Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 python-magnetrun (0.0.1-2) UNRELEASED; urgency=medium
 .
   * update to git rev fe339bedec
Author: Christophe Trophime <christophe.trophime@lncmi.cnrs.fr>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2022-01-18

--- /dev/null
+++ python-magnetrun-0.0.1/python_magnetrun/power.py
@@ -0,0 +1,191 @@
+#! /usr/bin/python
+
+import math
+
+import numpy as np
+from mpl_toolkits.mplot3d import axes3d
+import matplotlib.pyplot as plt
+from matplotlib import cm
+
+def interpolateI(I0, B0, I1, B1, B):
+    """
+    interpolate value of I(B) from (I0,B0) to (I1,B1)
+
+    """
+    return (I1-I0)/(B1-B0) * (B-B0) + I0 
+    
+# Magnet caracteristics (load from Magfile)
+rh=0.01300
+rb=0.00956
+
+fh=8.892
+fb=3.325
+
+ih_max=31
+ib_max=31
+
+b_max=(fh*1.e-1)*ih_max+(fb*1.e-1)*ib_max
+print("Bmax=%g" % b_max )
+
+
+dim=240
+
+p = lambda x, y: (rh*x**2 + rb*y**2) 
+
+
+# Loop over B field
+ih = np.linspace(0, ih_max, dim)
+
+ih_min=[]
+ib_min=[]
+p_min=[]
+b=[]
+
+ihtmin=[]
+ibtmin=[]
+ptmin=[]
+
+B_thresold = 0
+
+print("\tB0\tih\tib\tpmin\t")
+print("----------------------------------------------------------")
+for B0 in np.linspace(0, b_max*1.00001, dim): #np.arange(0.1, b_max*1.001, 0.1):
+    b.append(B0)
+    ib = lambda x: (B0-(fh*1.e-1)*x)/(fb*1.e-1)
+    pt= lambda x: rh*x**2 + rb*ib(x)**2
+ 
+    # Find minimum
+    tmp=pt(ih)
+    minpt = np.amin(tmp)
+    minIndexpt = np.where(tmp == np.amin(tmp) )
+    xmin = ih[minIndexpt[0][0]]
+    ymin = ib(xmin)
+    pmin=minpt 
+    # print("minpt=",minpt,ih[minIndexpt[0][0]],ib(ih[minIndexpt[0][0]]), pt(ih[minIndexpt[0][0]]) )
+    
+    # # Find minimum
+    # minP = np.amin(p(ih,ib(ih)))
+    # minIndex = np.where(p(ih,ib(ih)) == np.amin(p(ih,ib(ih))) )
+    # #print("minIndex=",minIndex,type(minIndex[0]))
+    # xmin = ih[minIndex[0][0]]
+    # ymin = ib(xmin)
+    # pmin=minP 
+
+    ih_min.append(xmin)
+    ib_min.append(ymin)
+    p_min.append(pmin)
+    
+    print("Numpy: %8.6f\t%8.6f\t%8.6f\t%8.6f" % (B0, xmin, ymin, pmin) )# "min=", minP, minIndex)
+
+    # Compute analyticaly
+    xmin = rb*fh/fb * B0/(fb*1.e-1) / (rh+rb*(fh/fb)**2)
+    if xmin >= ih_max:
+        xmin = ih_max
+        if B_thresold == 0:
+            B_thresold = B0
+        
+    print("Ana:   %8.6f\t%8.6f\t%8.6f\t%8.6f\t%s" % (B0,xmin,ib(xmin),pt(xmin), (B_thresold > 0) ) )
+    ptmin.append(pt(xmin))
+    ihtmin.append(xmin)
+    ibtmin.append(ib(xmin))
+
+print("B_thresold:   %8.6f" % B_thresold )
+
+
+# Similar plot to Kevin
+
+fig = plt.figure()
+ax = plt.gca()
+ax.set(xlabel='B [T]', ylabel='I [kA]')
+
+tmp_ih = np.linspace(0, ih_max, dim)
+tmp_ib = np.linspace(0, ib_max, dim)
+ax.plot(b, tmp_ih, label="Helices (orig)" % (B_thresold), color="blue")
+ax.plot(b, tmp_ib, label="Bitter (orig)" % (B_thresold), color="blue",  linestyle='--')
+
+ax.plot(b, ihtmin, label="Helices (opt: %8.4f T)" % (B_thresold), color="red")
+ax.plot(b, ibtmin, label="Bitter (opt: %8.4f T)" % (B_thresold), color="red",  linestyle='--')
+
+
+# Activate  Eco for B<=ratio*B_thresold
+
+ratio = 0.95
+ih=[]
+val_thresold = 0
+for i,x in enumerate(ihtmin):
+    if b[i]<= ratio*B_thresold:
+        val = x
+        val_thresold = x
+    else:
+        val = interpolateI(val_thresold,ratio*B_thresold, ih_max, b_max, b[i])
+    ih.append(val)
+
+ib=[]
+val_thresold = 0
+for i,x in enumerate(ibtmin):
+    if b[i]<= ratio*B_thresold:
+        val = x
+        val_thresold = x
+    else:
+        val = interpolateI(val_thresold,ratio*B_thresold, ib_max, b_max, b[i])
+    ib.append(val)
+    
+ax.plot(b, ih, label="Helices (%8.4f T)" % (ratio*B_thresold), color="green" )
+ax.plot(b, ib, label="Bitter (%8.4f T)" % (ratio*B_thresold), linestyle='--', color="green" )
+ax.legend(loc='best')
+ax.grid(b=True)
+plt.show()
+
+# View optim sol and ratio
+fig = plt.figure()
+ax = plt.gca()
+
+(x, y) = np.meshgrid(np.linspace(0, ih_max, dim), 
+                     np.linspace(0, ib_max, dim))
+
+CS = plt.contour(x, y, p(x,y), 20)
+plt.clabel(CS, inline=1, fontsize=10)
+plt.title('Simplest default with labels')
+# ax.plot_surface(x, y, p(x,y), color='blue') #cmap=cm.magma)
+#ax.set(xlabel='ih', ylabel='ib', zlabel='P',  title='Total Power')
+ax.set(xlabel='ih [kA]', ylabel='ib [kA]',  title='Total Power')
+
+ax.set_xlim([0,ih_max])
+ax.set_ylim([0,ib_max])
+
+for B0 in np.linspace(0, b_max*1.00001, dim):
+    tmp_ib = lambda x: (B0-(fh*1.e-1)*x)/(fb*1.e-1)
+    ax.plot(tmp_ih, tmp_ib(tmp_ih), lw=1, linestyle='--', color='lightgrey', label=("%s T" % B0) )
+
+# ax.scatter(ih_min, ib_min, s=10, color="green")
+tmp_ib = np.linspace(0, ib_max, dim)
+ax.scatter(tmp_ih, tmp_ib, s=10, color="blue")
+ax.scatter(ihtmin, ibtmin, s=10, color="red")
+ax.scatter(ih, ib, s=10, color="green")
+
+fig.tight_layout()
+fig.savefig('Power.png')
+plt.show()
+
+# # Plot saved power for Optim dist
+# fig = plt.figure()
+# ax = plt.gca()
+# ax.set(xlabel='B [T]', ylabel='P [MW]')
+
+# i=[x/(fh*1.e-4+fb*1.e-4)/1.e+3 for x in b]
+# power=[p(x,x) for x in i]
+# saved=[]
+# for i in range(len(p_min)):
+#     saved.append(power[i]-p_min[i]) 
+# ax.plot(b, saved,  label='Saved Power')
+
+    
+# saved=[]
+# for i in range(len(p_min)):
+#     saved.append(power[i]-ptmin[i]) 
+# ax.plot(b, saved, lw=1, linestyle='--', label=("computed") )
+# ax.legend(loc='best')
+# ax.grid(b=True)
+
+# plt.show()
+
